'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var axios = _interopDefault(require('axios'));
var askSdkCore = require('ask-sdk-core');
var core = require('@ask-utils/core');

/**
 * Create random string to create a request token
 */
const createRandomToken = () => Math.random().toString(36).slice(-8);
/**
 * Get directive object to sent Buy request
 * @param productId string - ISP product id
 * @param token [string] - request token
 */
const getBuyProductDirective = (productId, token = createRandomToken()) => {
    return {
        type: 'Connections.SendRequest',
        name: 'Buy',
        payload: {
            InSkillProduct: {
                productId
            }
        },
        token
    };
};
const getCancelProductDirective = (productId, token = createRandomToken()) => {
    return {
        type: 'Connections.SendRequest',
        name: 'Cancel',
        payload: {
            InSkillProduct: {
                productId
            }
        },
        token
    };
};

/**
 * Get purchaseable products
 * @param inSkillProductList {services.monetization.InSkillProduct[]}
 */
const getAllPurchasableProducts = (inSkillProductList) => {
    return inSkillProductList.filter((record) => {
        if (record.entitled === 'ENTITLED')
            return false;
        return record.purchasable === 'PURCHASABLE';
    });
};
/**
 * search by entitled state
 * @param inSkillProductList {services.monetization.InSkillProduct[]}
 * @param status {services.monetization.EntitledState}
 */
const searchProductByEntitledStatus = (inSkillProductList, status) => {
    return inSkillProductList.filter((record) => record.entitled === status);
};
/**
 * Get entitled products
 * @param inSkillProductList {services.monetization.InSkillProduct[]}
 */
const getAllEntitledProducts = (inSkillProductList) => {
    const product = searchProductByEntitledStatus(inSkillProductList, 'ENTITLED');
    console.log('Currently entitled products: %j', product);
    return product;
};
/**
 * Get product by the product name
 * @param inSkillProductList {services.monetization.InSkillProduct[]}
 * @param name {string}
 */
const getProductByName = (inSkillProductList, name) => {
    if (inSkillProductList.length < 1)
        return null;
    const product = inSkillProductList.find((product) => product.name === name);
    if (!product)
        return null;
    return product;
};

const isSkillConnectionResponse = (request) => {
    return request.type === 'Connections.Response';
};
const isSkillConnectionRequest = (request) => {
    return request.type === 'Connections.Request';
};
const isUpsellConnectionResponse = (handlerInput) => {
    const { request } = handlerInput.requestEnvelope;
    if (!isSkillConnectionResponse(request))
        return false;
    return request.name === 'Upsell';
};
const isCancelConnectionResponse = (handlerInput) => {
    const { request } = handlerInput.requestEnvelope;
    if (!isSkillConnectionResponse(request))
        return false;
    return request.name === 'Cancel';
};
const isBuyConnectionResponse = (handlerInput) => {
    const { request } = handlerInput.requestEnvelope;
    if (!isSkillConnectionResponse(request))
        return false;
    return request.name === 'Buy';
};
const isUpsellConnectionResposneRequest = (request) => {
    return isSkillConnectionResponse(request) && request.name === 'Upsell';
};
const isBuyConnectionResposneRequest = (request) => {
    return isSkillConnectionResponse(request) && request.name === 'Buy';
};
const isCancelConnectionResposneRequest = (request) => {
    return isSkillConnectionResponse(request) && request.name === 'Cancel';
};
const getProductIdFromConnectionResponse = (request) => {
    if (!isSkillConnectionRequest(request))
        return null;
    if (!request.payload)
        return null;
    return request.payload.productId || null;
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class APIClient {
    constructor(requestEnvelope, isDebug = true) {
        this.token = askSdkCore.getApiAccessToken(requestEnvelope);
        this.locale = askSdkCore.getLocale(requestEnvelope);
        this.endpoint = requestEnvelope.context.System.apiEndpoint;
        this.isDebug = isDebug;
    }
    getURL(productId) {
        const url = `${this.endpoint}/v1/users/~current/skills/~current/inSkillProducts`;
        if (!productId)
            return url;
        return `${url}/productId`;
    }
    createAxiosRequestObject(productId) {
        return {
            method: 'GET',
            url: this.getURL(productId),
            headers: {
                'Content-type': 'application/json',
                'Accept-Language': this.locale,
                Authorization: `Bearer ${this.token}`
            }
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = this.createAxiosRequestObject(productId);
            if (this.isDebug)
                console.log('[Get ISP product] %j', param);
            const { data } = yield axios(param);
            if (this.isDebug)
                console.log('[Get ISP product] %j', data);
            return data;
        });
    }
    listProducts() {
        return this.get();
    }
    getProduct(productId) {
        return this.get(productId);
    }
}
class ISPProductClient extends APIClient {
    // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
    constructor(handlerInput, isDebug = true) {
        super(handlerInput.requestEnvelope, isDebug);
        this.cacheUsage = 'enable';
        this.products = [];
        this.attributeManager = handlerInput.attributesManager;
    }
    getCacheStatus() {
        return this.cacheUsage;
    }
    /**
   * Disallow to use the session attributes item at first
   **/
    disabledCache() {
        this.cacheUsage = 'disable';
        return this;
    }
    /**
   * Allow to use the session attributes item at first
   **/
    enableCache() {
        this.cacheUsage = 'enable';
        return this;
    }
    /**
   * Check product avaliable status
   * If products is empty, try to fetch at once
   */
    hasProducts() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.products || this.products.length < 1)
                yield this.fetchLists();
            if (!this.products || this.products.length < 1)
                return false;
            return true;
        });
    }
    /**
   * get product from session attributes
   */
    getCachedProducts() {
        const { products } = this.attributeManager.getSessionAttributes();
        if (products && products.length > 0) {
            this.products = products;
        }
        return this.products;
    }
    /**
   * Fetch the ISP API.
   * If cacheUsage is enabled, it will return from session attributes at first
   */
    fetchLists() {
        return __awaiter(this, void 0, void 0, function* () {
            const atts = this.attributeManager.getSessionAttributes();
            if (this.cacheUsage === 'enable') {
                const cachedProducts = this.getCachedProducts();
                if (cachedProducts && cachedProducts.length > 0) {
                    return;
                }
            }
            const data = yield this.get();
            const products = data.inSkillProducts;
            this.products = products;
            this.attributeManager.setSessionAttributes(Object.assign(Object.assign({}, atts), { products }));
        });
    }
    /**
   * get product by product id
   * @param productId {string}
   */
    getProductById(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cacheUsage === 'enable') {
                const cachedProducts = this.getCachedProducts();
                if (cachedProducts && cachedProducts.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                    const item = cachedProducts.find(cache => cache.productId === productId);
                    if (item)
                        return item;
                }
            }
            const product = yield this.get(productId);
            return product;
        });
    }
    /**
   * get products
   */
    getProducts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetchLists();
            return this.products;
        });
    }
    /**
   * Find product by the list number
   * @param userInputNo {number} list number
   */
    findProductByNo(userInputNo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasProducts()))
                return null;
            const target = this.products[userInputNo];
            return target;
        });
    }
    /**
   * Find product by the specific id
   * @param productId {string} product id
   */
    findProductById(productId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasProducts()))
                return null;
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            const product = this.products.find(product => product.productId === productId);
            if (!product)
                return null;
            return product;
        });
    }
    /**
   * Find product by the product name
   * @param productName {string} product name
   */
    findProductByName(productName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasProducts()))
                return null;
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            const product = this.products.find(product => product.name === productName);
            if (!product)
                return null;
            return product;
        });
    }
    /**
   * Find product by several condition
   * @param condition {productName?: string, userInputNo?: number, productId?: string} search conditions
   */
    searchProduct(condition) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!condition.productName && !condition.userInputNo && !condition.productId)
                throw new Error('No search condition');
            if (condition.userInputNo)
                return this.findProductByNo(condition.userInputNo);
            if (condition.productName)
                return this.findProductByName(condition.productName);
            if (condition.productId)
                return this.findProductById(condition.productId);
            throw new Error('Invalid search condition');
        });
    }
}

class ContentBuilder {
    constructor(locale, responseBuilder) {
        this.contents = {};
        this.locale = locale;
        this.responseBuilder = responseBuilder;
    }
    isJP() {
        return /^ja/.test(this.locale);
    }
    getResponse() {
        const { speechText, repromptText, directive } = this.contents;
        if (speechText)
            this.responseBuilder.speak(speechText);
        if (repromptText)
            this.responseBuilder.reprompt(repromptText);
        if (directive)
            this.responseBuilder.addDirective(directive);
        return this.responseBuilder.getResponse();
    }
}
class ISPContentBuilder extends ContentBuilder {
    constructor(locale, responseBuilder, productName, product) {
        super(locale, responseBuilder);
        if (productName)
            this.productName = productName;
        if (product)
            this.product = product;
    }
    setProduct(product) {
        this.product = product;
        return this;
    }
    getProduct() {
        const { product } = this;
        if (!product)
            throw new Error('No products');
        return product;
    }
    setProductName(name) {
        this.productName = name;
        return this;
    }
    getProductName() {
        if (!this.productName)
            throw new Error('No product name');
        return this.productName;
    }
    /**
   * If the device or account does not supports ISP
   */
    getUnSupportedISPResponse() {
        if (this.isJP()) {
            return {
                speechText: [
                    'すみません。',
                    'お使いのデバイス・アプリでは、スキル内課金を利用することができません。',
                    '別のデバイスを利用するか、アレクサアプリから設定を確認してもう一度お試しください。',
                    '次はなにをしますか？',
                    'スキルを終了して、アプリの設定を確認したい場合は「終了」と話しかけてください。'
                ].join(' '),
                repromptText: [
                    '次はなにをしますか？',
                    'スキルを終了して、アプリの設定を確認したい場合は「終了」と話しかけてください。'
                ].join(' ')
            };
        }
        return {
            speechText: [
                'Sorry, you can not purchase by the device.',
                'Please check your device and application settings by the Alexa app.',
                'What will you do the next?'
            ].join(' '),
            repromptText: [
                'What will you do the next?',
                'If you want to stop the skill, please say me "STOP".'
            ].join(' ')
        };
    }
    setUnSupportedISPResponse() {
        this.contents = this.getUnSupportedISPResponse();
        return this;
    }
    /**
   * Product does not found response
   */
    getProductsNotFoundResponse() {
        if (this.isJP()) {
            return {
                speechText: [
                    'すみません。商品が見つかりませんでした。',
                    '他に何をしますか？'
                ].join(' '),
                repromptText: '他に何をしますか？'
            };
        }
        return {
            speechText: 'I can\'t find any products you can buy. What do you want to do next?',
            repromptText: 'What do you want to do next?'
        };
    }
    setProductsNotFoundResponse() {
        this.contents = this.getProductsNotFoundResponse();
        return this;
    }
    /**
   * Product does not found response
   */
    getProductNotFoundResponse() {
        try {
            const productName = this.getProductName();
            if (this.isJP()) {
                return {
                    speechText: [
                        `${productName}を購入することができます。`,
                        `詳細を聞きたい場合は「${productName}について教えて」、`,
                        `購入する場合は「${productName}を購入」と話しかけてください。`,
                        'どうしますか？'
                    ].join(' '),
                    repromptText: '購入・詳細、どちらにしますか？'
                };
            }
            return {
                speechText: `${productName}. what item do you want?`,
                repromptText: `${productName}. what item do you want?`
            };
        }
        catch (e) {
            return this.getProductsNotFoundResponse();
        }
    }
    setProductNotFoundResponse() {
        this.contents = this.getProductNotFoundResponse();
        return this;
    }
    /**
   * If product not found
   */
    getCanNotBuyTheProductResponse() {
        if (this.isJP()) {
            return {
                speechText: 'すみません。その商品は現在購入できません。他に何をしますか？',
                repromptText: '他に何をしますか？'
            };
        }
        return {
            speechText: "I don't think we have a product by that name.  Can you try again?",
            repromptText: "I didn't catch that. Can you try again?"
        };
    }
    setCanNotBuyTheProductResponse() {
        this.contents = this.getCanNotBuyTheProductResponse();
        return this;
    }
    /**
   * If product already purchased
   */
    getEntitledProductResponse() {
        if (this.isJP()) {
            return {
                speechText: 'その商品はすでに購入済の様子です。他に何をしますか？',
                repromptText: '他に何をしますか？'
            };
        }
        return {
            speechText: 'You already entitled the product. What will you do for next?',
            repromptText: 'What will you do for next?'
        };
    }
    setEntitledProductResponse() {
        this.contents = this.getEntitledProductResponse();
        return this;
    }
}

class BuyContentBuilder extends ISPContentBuilder {
    setBuyDirective(productId) {
        this.contents.directive = getBuyProductDirective(productId);
        return this;
    }
}

class BuyResponseContentBuilder extends ISPContentBuilder {
    // purchaseResult === 'DECLINED'
    getDeclinedPurchaseResult() {
        const product = this.getProduct();
        if (this.isJP()) {
            return {
                speechText: [
                    `${product && product.name ? product.name : '商品'}に興味を持ってくれてありがとうございます。`,
                    'また機会が購入してくださいね。',
                    '次はなにをしますか？'
                ].join(' '),
                repromptText: '次はなにをしますか？'
            };
        }
        return {
            speechText: [
                `Thanks for your interest in the ${product && product.name ? product.name : 'product'}.`,
                'What will you do for next?'
            ].join(' '),
            repromptText: 'What will you do for next?'
        };
    }
    setDeclinedPurchaseResult() {
        this.contents = this.getDeclinedPurchaseResult();
        return this;
    }
    // purchaseResult === 'ACCEPTED'
    getAcceptedPurchaseResult() {
        const product = this.getProduct();
        if (this.isJP()) {
            return {
                speechText: [
                    `${product && product.name ? product.name : '商品'}の購入ありがとうございます。`,
                    '次は何をしますか？'
                ].join(' '),
                repromptText: '次は何をしますか？'
            };
        }
        return {
            speechText: [
                `You have purchased the ${product && product.name ? product.name : 'product'}.`,
                'What will you do for next?'
            ].join(' '),
            repromptText: 'What will you do for next?'
        };
    }
    setAcceptedPurchaseResult() {
        this.contents = this.getAcceptedPurchaseResult();
        return this;
    }
    getFailedPurchaseResult() {
        if (this.isJP()) {
            return {
                speechText: [
                    'スキル商品の購入処理に失敗しました。',
                    'もう一度トライするか、アレクサアプリからサポートに問い合わせてください。'
                ].join(' ')
            };
        }
        return {
            speechText: [
                'There was an error handling your purchase request.',
                'Please try again or contact us for help.'
            ].join(' ')
        };
    }
    setFailedPurchaseResult() {
        this.contents = this.getFailedPurchaseResult();
        return this;
    }
}

class RefundContentBuilder extends ISPContentBuilder {
    /**
   * If product not purchased yet
   */
    getNoEntitledProductResponse() {
        const product = this.getProduct();
        if (this.isJP()) {
            return {
                speechText: [
                    `${product.name} は購入していない商品ですので、キャンセルできません。`,
                    '他になにをしますか？'
                ].join(' '),
                repromptText: '他に何をしますか？'
            };
        }
        return {
            speechText: [
                'You can not refund it.',
                `Because the ${product.name} is not purchased.`,
                'What do you want to do next?'
            ].join(' '),
            repromptText: 'What will you do for next?'
        };
    }
    setNoEntitledProductResponse() {
        this.contents = this.getNoEntitledProductResponse();
        return this;
    }
    setCancelDirective(productId) {
        this.contents.directive = getCancelProductDirective(productId);
        return this;
    }
}

class RefundResponseContentBuilder extends ISPContentBuilder {
    // purchaseResult === 'DECLINED'
    getDeclinedRefundResult() {
        if (this.isJP()) {
            return {
                speechText: [
                    '承知しました。',
                    '次はなにをしますか？'
                ].join(' '),
                repromptText: '次はなにをしますか？'
            };
        }
        return {
            speechText: [
                'Ok.',
                'What will you do for next?'
            ].join(' '),
            repromptText: 'What will you do for next?'
        };
    }
    setDeclinedRefundResult() {
        this.contents = this.getDeclinedRefundResult();
        return this;
    }
    // purchaseResult === 'ACCEPTED'
    getAcceptedRefundResult() {
        if (this.isJP()) {
            return {
                speechText: [
                    'お使いいただいてありがとうございました。',
                    '次は何をしますか？'
                ].join(' '),
                repromptText: '次は何をしますか？'
            };
        }
        return {
            speechText: [
                'Thanks for enjoy the packages. ',
                'What will you do for next?'
            ].join(' '),
            repromptText: 'What will you do for next?'
        };
    }
    setAcceptedRefundResult() {
        this.contents = this.getAcceptedRefundResult();
        return this;
    }
    getFailedRefundResult() {
        if (this.isJP()) {
            return {
                speechText: [
                    'キャンセル処理に失敗しました。',
                    'もう一度トライするか、アレクサアプリからサポートに問い合わせてください。'
                ].join(' ')
            };
        }
        return {
            speechText: [
                'There was an error handling your refund request.',
                'Please try again or contact us for help.'
            ].join(' ')
        };
    }
    setFailedRefundResult() {
        this.contents = this.getFailedRefundResult();
        return this;
    }
}

class ProductDetailResponseContentBuilder extends ISPContentBuilder {
    // purchaseResult === 'DECLINED'
    getProductDetail() {
        const product = this.getProduct();
        if (this.isJP()) {
            return {
                speechText: [
                    product.summary,
                    '購入しますか？'
                ].join(' '),
                repromptText: '購入しますか？'
            };
        }
        return {
            speechText: [
                product.summary,
                'Will you buy the product?'
            ].join(' '),
            repromptText: 'Will you buy the product?'
        };
    }
    setProductDetail() {
        this.contents = this.getProductDetail();
        return this;
    }
}

class ProductListResponseContentBuilder extends ISPContentBuilder {
    constructor() {
        super(...arguments);
        this.listProducts = [];
    }
    setProductLists(list) {
        this.listProducts = list;
        return this;
    }
    getProductLists() {
        return this.listProducts;
    }
    getListProducts() {
        const products = this.getProductLists();
        if (products.length === 1) {
            const productText = `<p>${products[0].name}. ${products[0].summary}</p>`;
            if (this.isJP()) {
                return {
                    speechText: [
                        productText,
                        '<p>どの商品を購入しますか？</p>'
                    ].join(' '),
                    repromptText: 'どの商品を購入しますか？'
                };
            }
            return {
                speechText: [
                    productText,
                    'What item will you buy?'
                ].join(' '),
                repromptText: 'What item will you buy?'
            };
        }
        if (this.isJP()) {
            return {
                speechText: [
                    products.map((product, i) => {
                        return `<p>${i + 1}番目。 ${product.name}. ${product.summary}</p>`;
                    }).join(''),
                    '<p>どの商品を購入しますか？</p>'
                ].join(' '),
                repromptText: 'どの商品を購入しますか？'
            };
        }
        return {
            speechText: [
                products.map((product, i) => {
                    return `<p>No.${i + 1}. ${product.name}. ${product.summary}</p>`;
                }).join('<p>Next.</p>'),
                'What item will you buy?'
            ].join(' '),
            repromptText: 'What item will you buy?'
        };
    }
    setListProducts() {
        this.contents = this.getListProducts();
        return this;
    }
}

/**
 * Load In Skill Product interceptor
 * @external https://developer.amazon.com/ja/blogs/alexa/post/75ee61df-8365-44bb-b28f-e708000891ad/how-to-use-interceptors-to-simplify-handler-code-and-cache-product-and-purchase-information-in-monetized-alexa-skills
 * @example
 * ```typescript
 * // set it into the request interceptor
 * .addRequestInteceptor(loadISPDataInterceptor)
 *
 * // get product from session attributes
 * import { getAllEntitledProducts } from '@ask-utils/isp'
 *
 * const { inSkillProducts } = handlerInput.attributesManager.getSessionAttributes()
 * const entitledProducts = getAllEntitledProducts(inSkillProducts)
 * ```
 */
const loadISPDataInterceptor = {
    process({ requestEnvelope, serviceClientFactory, attributesManager }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!requestEnvelope.session || !askSdkCore.isNewSession(requestEnvelope))
                return;
            if (!serviceClientFactory)
                return;
            // new session, check to see what products are already owned.
            try {
                const locale = askSdkCore.getLocale(requestEnvelope);
                const ms = serviceClientFactory.getMonetizationServiceClient();
                const result = yield ms.getInSkillProducts(locale);
                const sessionAttributes = attributesManager.getSessionAttributes();
                sessionAttributes.inSkillProducts = result.inSkillProducts;
                attributesManager.setSessionAttributes(sessionAttributes);
            }
            catch (error) {
                console.log(`Error calling InSkillProducts API: ${error}`);
            }
        });
    }
};
/**
 * Load In Skill Product interceptor alternative
 * @example
 * ```typescript
 * // set it into the request interceptor
 * .addRequestInteceptor(loadISPDataInterceptor)
 *
 * // get product from session attributes
 * import { getAllEntitledProducts } from '@ask-utils/isp'
 *
 * const { products } = handlerInput.attributesManager.getSessionAttributes()
 * const entitledProducts = getAllEntitledProducts(products)
 * ```
 */
const altLoadISPDataInterceptor = {
    process(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope } = handlerInput;
            if (!requestEnvelope.session || !askSdkCore.isNewSession(requestEnvelope))
                return;
            // new session, check to see what products are already owned.
            try {
                const client = new ISPProductClient(handlerInput);
                yield client.disabledCache().getProducts();
            }
            catch (error) {
                console.log(`Error calling InSkillProducts API: ${error}`);
            }
        });
    }
};

const getISPCurrentState = (attributesManager) => {
    return core.StateManager.getCurrentState(attributesManager);
};
const updateISPState = (attributesManager, state) => {
    return core.StateManager.updateState(attributesManager, state);
};
const isMatchedISPState = (attributesManager, state) => {
    return state === getISPCurrentState(attributesManager);
};
const getProductNameFromSlot = (handlerInput) => {
    const productName = core.getSlotValue(handlerInput, 'product');
    return productName;
};
const getUserInputProductNo = (handlerInput) => {
    const slotValue = core.getSlotValue(handlerInput, 'productNo');
    if (!slotValue)
        return null;
    const productNo = Number(slotValue) - 1;
    if (productNo < 0)
        return null;
    return productNo;
};
const getProduct = (handlerInput) => __awaiter(void 0, void 0, void 0, function* () {
    const productName = getProductNameFromSlot(handlerInput);
    const productNo = getUserInputProductNo(handlerInput);
    console.log('Requested product %j', { productName, productNo });
    // Slotに値がない
    if (!productName && !productNo) {
        const sessionProduct = core.getSessionAttribute(handlerInput, 'product');
        return sessionProduct || null;
    }
    const client = new ISPProductClient(handlerInput, true);
    yield client.fetchLists();
    const product = yield client.searchProduct({
        productName: productName || undefined,
        userInputNo: productNo || undefined
    });
    return product;
});

const ProductDetailIntentHandler = {
    canHandle(handlerInput) {
        return core.isMatchedIntent(handlerInput, 'ProductDetailIntent');
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            const responseBuilder = new ProductDetailResponseContentBuilder(locale, handlerInput.responseBuilder);
            // ISP対応してない（service clientが無い）
            if (!serviceClientFactory) {
                return responseBuilder.setUnSupportedISPResponse().getResponse();
            }
            const productName = getProductNameFromSlot(handlerInput);
            const productNo = getUserInputProductNo(handlerInput);
            if (productName)
                responseBuilder.setProductName(productName);
            // Slotに値がない
            if (!productName && !productNo) {
                return responseBuilder.setProductNotFoundResponse().getResponse();
            }
            const client = new ISPProductClient(handlerInput);
            yield client.fetchLists();
            const product = yield client.searchProduct({
                productName: productName || undefined,
                userInputNo: productNo || undefined
            });
            // みつからない or 買えない商品
            if (!product) {
                return responseBuilder.setProductNotFoundResponse().getResponse();
            }
            if (product.purchasable === 'NOT_PURCHASABLE') {
                return responseBuilder.setCanNotBuyTheProductResponse().getResponse();
            }
            // 購入済み
            if (product.entitled === 'ENTITLED') {
                return responseBuilder.setEntitledProductResponse().getResponse();
            }
            responseBuilder.setProduct(product);
            updateISPState(handlerInput.attributesManager, 'BUY');
            core.updateSessionAttributes(handlerInput, {
                product
            });
            return responseBuilder
                .setProductDetail()
                .getResponse();
        });
    }
};

const ProductListIntentHandler = {
    canHandle(handlerInput) {
        return core.isMatchedIntent(handlerInput, 'ProductListIntent');
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            const responseBuilder = new ProductListResponseContentBuilder(locale, handlerInput.responseBuilder);
            // ISP対応してない（service clientが無い）
            if (!serviceClientFactory) {
                return responseBuilder.setUnSupportedISPResponse().getResponse();
            }
            const client = new ISPProductClient(handlerInput);
            const { inSkillProducts } = yield client.listProducts();
            const products = getAllPurchasableProducts(inSkillProducts);
            // みつからない or 買えない商品
            if (!products || products.length < 1) {
                return responseBuilder.setProductsNotFoundResponse().getResponse();
            }
            updateISPState(handlerInput.attributesManager, 'BUY');
            core.updateSessionAttributes(handlerInput, {
                products
            });
            return responseBuilder
                .setProductLists(products)
                .setListProducts()
                .getResponse();
        });
    }
};

class HandlerBuilder {
    constructor() {
        this.canHandleFilter = () => true;
        this.canHandle = (handlerInput) => {
            return this.canHandleFilter(handlerInput);
        };
        this.handle = (handlerInput) => {
            throw new Error(`Unsupported request: ${JSON.stringify(handlerInput)}`);
        };
    }
    setHandleCondition(condition) {
        this.canHandleFilter = condition;
        return this;
    }
    setHandle(handle) {
        this.handle = handle;
        return this;
    }
    updateHandler(condition, handle) {
        this.setHandle(handle);
        this.setHandleCondition(condition);
        return this;
    }
    replaceHandler(handler) {
        if (handler.canHandle)
            this.setHandleCondition(handler.canHandle);
        if (handler.handle)
            this.setHandle(handler.handle);
        return this;
    }
    getHandler() {
        return {
            canHandle: this.canHandle,
            handle: this.handle
        };
    }
}

const makeParagraphText = (messages) => {
    return `<p>${messages.join(' </p><p>')}</p>`;
};
const UnSupportedISPResponse = (locale) => {
    if (/^ja/.test(locale)) {
        return {
            speechText: makeParagraphText([
                'すみません。',
                'お使いのデバイス・アプリでは、スキル内課金を利用することができません。',
                '別のデバイスを利用するか、アレクサアプリから設定を確認してもう一度お試しください。',
                '次はなにをしますか？',
                'スキルを終了して、アプリの設定を確認したい場合は「終了」と話しかけてください。'
            ]),
            repromptText: makeParagraphText([
                '次はなにをしますか？',
                'スキルを終了して、アプリの設定を確認したい場合は「終了」と話しかけてください。'
            ])
        };
    }
    return {
        speechText: makeParagraphText([
            'Sorry, you can not purchase by the device.',
            'Please check your device and application settings by the Alexa app.',
            'What will you do the next?'
        ]),
        repromptText: makeParagraphText([
            'What will you do the next?',
            'If you want to stop the skill, please say me "STOP".'
        ])
    };
};
const NoProductResponse = (responseBuilder, locale, products) => {
    const purchaseableProducts = products ? getAllPurchasableProducts(products) : [];
    const purchaseableProductText = purchaseableProducts.map(product => product.name).join(', ');
    // no purchaseable products
    if (!purchaseableProductText) {
        if (/^ja/.test(locale)) {
            return responseBuilder.speak([
                'すみません。',
                '購入できる商品は、すでに購入済の様子です。',
                '他の機能などについて知りたい場合は、ヘルプと話しかけてください。'
            ].join(''))
                .reprompt('どちらにしますか？使い方についてもっと知りたい場合は、「ヘルプ」と言ってください。')
                .getResponse();
        }
        return responseBuilder.speak([
            'You already have all products..',
            'Qhat do you want?'
        ].join(' '))
            .reprompt('What do you want?')
            .getResponse();
    }
    if (/^ja/.test(locale)) {
        return responseBuilder.speak([
            `${purchaseableProductText}を購入することができます。`,
            purchaseableProducts && purchaseableProducts.length > 0 ? [
                `詳細を聞きたい場合は「${purchaseableProducts[0].name}について教えて」、`,
                `購入する場合は「${purchaseableProducts[0].name}を購入」のように話しかけてください。`
            ].join('')
                : '',
            'どうしますか？'
        ].join(' '))
            .reprompt('購入・詳細、どちらにしますか？使い方についてもっと知りたい場合は、「ヘルプ」と言ってください。')
            .getResponse();
    }
    return responseBuilder.speak([
        `You can buy ${purchaseableProductText} packages.`,
        'Buy or check the detail, what do you want?'
    ].join(' '))
        .reprompt('Buy or check the detail, what do you want?')
        .getResponse();
};

class BuyIntentHandlerBuilder extends HandlerBuilder {
    constructor() {
        super(...arguments);
        this.canHandle = (handlerInput) => {
            return this.canHandleFilter(handlerInput);
        };
    }
    static create() {
    }
}
const BuyIntentHandler = {
    canHandle(handlerInput) {
        if (core.isMatchedIntent(handlerInput, 'BuyIntent'))
            return true;
        if (core.isYesIntent(handlerInput)) {
            return isMatchedISPState(handlerInput.attributesManager, 'BUY');
        }
        return false;
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, responseBuilder, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            if (!serviceClientFactory) {
                const noISPResponse = UnSupportedISPResponse(locale);
                return responseBuilder.speak(noISPResponse.speechText)
                    .reprompt(noISPResponse.repromptText)
                    .getResponse();
            }
            const product = yield getProduct(handlerInput);
            // みつからない
            if (!product) {
                const client = new ISPProductClient(handlerInput);
                const { inSkillProducts } = yield client.listProducts();
                return NoProductResponse(responseBuilder, locale, inSkillProducts);
            }
            // 買えない商品
            if (product.purchasable === 'NOT_PURCHASABLE') {
                if (/^ja/.test(locale)) {
                    return responseBuilder
                        .speak('すみません。その商品は現在購入できません。他に何をしますか？')
                        .reprompt('他に何をしますか？')
                        .getResponse();
                }
                return responseBuilder
                    .speak("I don't think we have a product by that name.  Can you try again?")
                    .reprompt("I didn't catch that. Can you try again?")
                    .getResponse();
            }
            // ここで一旦データを保存する
            // Connectionの方にいくとセッションが切れるから
            const attributes = handlerInput.attributesManager.getSessionAttributes();
            const atts = yield handlerInput.attributesManager.getPersistentAttributes();
            const nextAttributes = Object.assign(atts, {
                ispLastSessionAttribtes: attributes
            });
            yield handlerInput.attributesManager.setPersistentAttributes(nextAttributes);
            yield handlerInput.attributesManager.savePersistentAttributes();
            return handlerInput.responseBuilder
                .addDirective(getBuyProductDirective(product.productId))
                .getResponse();
        });
    }
};

const BuyResponseHandler = {
    canHandle(handlerInput) {
        if (handlerInput.requestEnvelope.request.type !== 'Connections.Response')
            return false;
        return handlerInput.requestEnvelope.request.name === 'Buy' || handlerInput.requestEnvelope.request.name === 'Upsell';
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, responseBuilder, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            const client = new ISPProductClient(handlerInput);
            const products = yield client.getProducts();
            const productNames = products.map(p => p.name).join(/^ja/.test(locale) ? 'と' : 'and');
            const contents = new BuyResponseContentBuilder(locale, responseBuilder, productNames);
            if (!serviceClientFactory)
                return contents.setUnSupportedISPResponse().getResponse();
            const { request } = requestEnvelope;
            if (!isBuyConnectionResposneRequest(request) && !isUpsellConnectionResposneRequest(request)) {
                throw new Error('Invalid request object');
            }
            const productId = getProductIdFromConnectionResponse(requestEnvelope.request);
            if (!productId) {
                return contents.setProductNotFoundResponse().getResponse();
            }
            const product = yield client.getProductById(productId);
            contents.setProduct(product);
            if (Number(request.status.code) === 200) {
                const { purchaseResult } = request.payload;
                if (purchaseResult === 'DECLINED') {
                    return contents.setDeclinedPurchaseResult().getResponse();
                }
                if (purchaseResult === 'ACCEPTED') {
                    return contents.setAcceptedPurchaseResult().getResponse();
                }
            }
            console.log('Connections.Response indicated failure. error:' + request.status.message);
            return contents.setFailedPurchaseResult().getResponse();
        });
    }
};

const RefundIntentHandler = {
    canHandle(handlerInput) {
        return core.isMatchedIntent(handlerInput, 'RefundIntent');
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            const product = yield getProduct(handlerInput);
            const productName = getProductNameFromSlot(handlerInput);
            const responseBuilder = new RefundContentBuilder(locale, handlerInput.responseBuilder, productName || '');
            if (!serviceClientFactory) {
                return responseBuilder.setUnSupportedISPResponse().getResponse();
            }
            // みつからない
            if (!product)
                return responseBuilder.setProductNotFoundResponse().getResponse();
            responseBuilder.setProduct(product);
            if (product.entitled !== 'ENTITLED') {
                return responseBuilder.setNoEntitledProductResponse().getResponse();
            }
            return responseBuilder.setCancelDirective(product.productId).getResponse();
        });
    }
};

const RefundResponseHandler = {
    canHandle(handlerInput) {
        return handlerInput.requestEnvelope.request.type === 'Connections.Response' &&
            handlerInput.requestEnvelope.request.name === 'Cancel';
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { requestEnvelope, serviceClientFactory } = handlerInput;
            const locale = askSdkCore.getLocale(requestEnvelope);
            const responseBuilder = new RefundResponseContentBuilder(locale, handlerInput.responseBuilder);
            if (!serviceClientFactory) {
                return responseBuilder.setUnSupportedISPResponse().getResponse();
            }
            const { request } = requestEnvelope;
            if (!isCancelConnectionResposneRequest(request))
                throw new Error('Invalid request object');
            if (Number(request.status.code) === 200) {
                if (request.payload.purchaseResult === 'ACCEPTED') {
                    return responseBuilder.setAcceptedRefundResult().getResponse();
                }
                if (request.payload.purchaseResult === 'DECLINED') {
                    return responseBuilder.setDeclinedRefundResult().getResponse();
                }
            }
            return responseBuilder.setFailedRefundResult().getResponse();
        });
    }
};

const UpsellHandler = {
    canHandle(handlerInput) {
        return handlerInput.requestEnvelope.request.type === 'Connections.Response' &&
            handlerInput.requestEnvelope.request.name === 'Upsell';
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            return BuyResponseHandler.handle(handlerInput);
        });
    }
};

const ISPHandlers = [
    ProductDetailIntentHandler,
    ProductListIntentHandler,
    BuyIntentHandler,
    BuyResponseHandler,
    RefundIntentHandler,
    RefundResponseHandler,
    UpsellHandler
];

exports.APIClient = APIClient;
exports.BuyContentBuilder = BuyContentBuilder;
exports.BuyIntentHandler = BuyIntentHandler;
exports.BuyIntentHandlerBuilder = BuyIntentHandlerBuilder;
exports.BuyResponseContentBuilder = BuyResponseContentBuilder;
exports.BuyResponseHandler = BuyResponseHandler;
exports.ISPHandlers = ISPHandlers;
exports.ISPProductClient = ISPProductClient;
exports.ProductDetailIntentHandler = ProductDetailIntentHandler;
exports.ProductDetailResponseContentBuilder = ProductDetailResponseContentBuilder;
exports.ProductListIntentHandler = ProductListIntentHandler;
exports.ProductListResponseContentBuilder = ProductListResponseContentBuilder;
exports.RefundContentBuilder = RefundContentBuilder;
exports.RefundIntentHandler = RefundIntentHandler;
exports.RefundResponseContentBuilder = RefundResponseContentBuilder;
exports.RefundResponseHandler = RefundResponseHandler;
exports.UpsellHandler = UpsellHandler;
exports.altLoadISPDataInterceptor = altLoadISPDataInterceptor;
exports.createRandomToken = createRandomToken;
exports.getAllEntitledProducts = getAllEntitledProducts;
exports.getAllPurchasableProducts = getAllPurchasableProducts;
exports.getBuyProductDirective = getBuyProductDirective;
exports.getCancelProductDirective = getCancelProductDirective;
exports.getProductByName = getProductByName;
exports.getProductIdFromConnectionResponse = getProductIdFromConnectionResponse;
exports.isBuyConnectionResponse = isBuyConnectionResponse;
exports.isBuyConnectionResposneRequest = isBuyConnectionResposneRequest;
exports.isCancelConnectionResponse = isCancelConnectionResponse;
exports.isCancelConnectionResposneRequest = isCancelConnectionResposneRequest;
exports.isSkillConnectionRequest = isSkillConnectionRequest;
exports.isSkillConnectionResponse = isSkillConnectionResponse;
exports.isUpsellConnectionResponse = isUpsellConnectionResponse;
exports.isUpsellConnectionResposneRequest = isUpsellConnectionResposneRequest;
exports.loadISPDataInterceptor = loadISPDataInterceptor;
exports.searchProductByEntitledStatus = searchProductByEntitledStatus;
