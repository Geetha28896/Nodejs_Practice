'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Resolver = _interopDefault(require('class-resolver'));
var askUtils = require('ask-utils');
var askSdkCore = require('ask-sdk-core');
var askSdkRuntime = require('ask-sdk-runtime');
var core = require('@ask-utils/core');
var moment = _interopDefault(require('moment'));

const merge = (handler, target) => {
    const fallBackHandler = {
        canHandle() {
            return true;
        },
        handle(handlerInput) {
            return handlerInput.responseBuilder.getResponse();
        }
    };
    return Object.assign({}, fallBackHandler, target, handler);
};
class RequestHandlerFactory {
    static create(type, handler) {
        return new Resolver(new LaunchRequestHandlerFactory(), new FallbackIntentFactory()).resolve(type).handle(handler);
    }
}
class LaunchRequestHandlerFactory {
    supports(type) {
        return type === 'LaunchRequest';
    }
    handle(handler) {
        return merge(handler, {
            canHandle(handlerInput) {
                return askUtils.isLaunchRequest(handlerInput);
            }
        });
    }
}
class FallbackIntentFactory {
    supports() {
        return true;
    }
    handle(handler) {
        return merge(handler);
    }
}

const RepeatIntent = {
    canHandle(handlerInput) {
        return askUtils.isMatchedIntent(handlerInput, 'AMAZON.RepeatIntent');
    },
    handle(handlerInput) {
        const lastResponse = askUtils.getSessionAttribute(handlerInput, 'lastResponse');
        if (!lastResponse)
            throw new Error('No repeat content');
        return lastResponse;
    }
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const DeleteDisabledUserHandler = {
    canHandle(handlerInput) {
        return askSdkCore.getRequestType(handlerInput.requestEnvelope) === 'AlexaSkillEvent.SkillDisabled';
    },
    handle(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const { deletePersistentAttributes } = handlerInput.attributesManager;
            if (!deletePersistentAttributes)
                throw askSdkRuntime.createAskSdkError('DeleteDisabledUserHandler', 'deletePersistentAttributes is not defined. Please upgrade your ask-sdk.');
            yield deletePersistentAttributes();
            return handlerInput.responseBuilder.getResponse();
        });
    }
};

class HandlerBuilder {
    constructor() {
        this.canHandleFilter = () => true;
        this.handlerFilter = (handlerInput) => { throw new Error(`Unsupported request: ${JSON.stringify(handlerInput)}`); };
        this.canHandle = (handlerInput) => {
            return this.canHandleFilter(handlerInput);
        };
        this.handle = (handlerInput) => {
            return this.handlerFilter(handlerInput);
        };
    }
    setHandleCondition(condition) {
        this.canHandleFilter = condition;
        return this;
    }
    setHandle(handle) {
        this.handlerFilter = handle;
        return this;
    }
    updateHandler(condition, handle) {
        this.setHandle(handle);
        this.setHandleCondition(condition);
        return this;
    }
    replaceHandler(handler) {
        if (handler.canHandle)
            this.setHandleCondition(handler.canHandle);
        if (handler.handle)
            this.setHandle(handler.handle);
        return this;
    }
    getHandler() {
        return {
            canHandle: this.canHandle,
            handle: this.handle
        };
    }
}

class IntentHandlerBuilder extends HandlerBuilder {
    constructor(intentName) {
        super();
        this.canHandle = (handlerInput) => {
            if (!askUtils.isMatchedIntent(handlerInput, this.intentName))
                return false;
            return this.canHandleFilter(handlerInput);
        };
        this.intentName = intentName;
    }
}

class LaunchRequestrBuilder extends HandlerBuilder {
    constructor() {
        super(...arguments);
        this.canHandle = (handlerInput) => {
            if (!askUtils.isLaunchRequest(handlerInput))
                return false;
            return this.canHandleFilter(handlerInput);
        };
    }
}

class IntentHandlerFactory {
    static init(intentName) {
        if (!intentName)
            throw new Error('intentName is required');
        return new IntentHandlerBuilder(intentName);
    }
}
class HandlerFactory {
    static init(type, intentName) {
        if (type === 'IntentRequest') {
            return IntentHandlerFactory.init(intentName);
        }
        return new HandlerBuilder();
    }
}
class LaunchRequestFactory {
    static init() {
        return new LaunchRequestrBuilder();
    }
}

const SessionEndedRequestHandler = {
    canHandle(handlerInput) {
        return askSdkCore.getRequestType(handlerInput.requestEnvelope) === 'SessionEndedRequest';
    },
    handle(handlerInput) {
        const request = handlerInput.requestEnvelope.request;
        console.log(`Session ended with reason: ${request.reason}`);
        console.log('Error: %j', request.error);
        return handlerInput.responseBuilder.getResponse();
    }
};

const RecordTheResponseInterceptor = {
    process(handlerInput, response) {
        // No response text
        if (!response)
            return;
        // Session should be closed
        if (response.shouldEndSession === true)
            return;
        // Skill will be closed
        if (!response.reprompt)
            return;
        askUtils.updateSessionAttributes(handlerInput, {
            lastResponse: response
        });
    }
};

const SetLaunchCountInterceptor = {
    process(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (askUtils.isSkillEvent(input.requestEnvelope) || core.isAudioPlayerRequest(input.requestEnvelope))
                return;
            if (!askSdkCore.isNewSession(input.requestEnvelope))
                return;
            const defaultState = {
                launchCount: 0,
                lastLaunch: undefined
            };
            const data = yield askUtils.getPersistentAttributes(input, defaultState);
            askUtils.updateSessionAttributes(input, data);
            input.attributesManager.setPersistentAttributes(Object.assign(Object.assign({}, data), { launchCount: data.launchCount + 1, lastLaunch: moment().unix() }));
            yield input.attributesManager.savePersistentAttributes();
        });
    }
};

class ConstantsInterceptorFactory {
    static init(constants) {
        return {
            process({ attributesManager }) {
                return __awaiter(this, void 0, void 0, function* () {
                    const atts = attributesManager.getRequestAttributes();
                    attributesManager.setRequestAttributes(Object.assign(Object.assign({}, atts), { CONSTANTS: constants }));
                });
            }
        };
    }
}

exports.ConstantsInterceptorFactory = ConstantsInterceptorFactory;
exports.DeleteDisabledUserHandler = DeleteDisabledUserHandler;
exports.HandlerBuilder = HandlerBuilder;
exports.HandlerFactory = HandlerFactory;
exports.IntentHandlerBuilder = IntentHandlerBuilder;
exports.IntentHandlerFactory = IntentHandlerFactory;
exports.LaunchRequestFactory = LaunchRequestFactory;
exports.RecordTheResponseInterceptor = RecordTheResponseInterceptor;
exports.RepeatIntent = RepeatIntent;
exports.RequestHandlerFactory = RequestHandlerFactory;
exports.SessionEndedRequestHandler = SessionEndedRequestHandler;
exports.SetLaunchCountInterceptor = SetLaunchCountInterceptor;
