'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var awsSdk = require('aws-sdk');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const updateSessionAttributes = (handlerInput, updateObject) => {
    const atts = handlerInput.attributesManager.getSessionAttributes();
    handlerInput.attributesManager.setSessionAttributes(Object.assign(atts, updateObject));
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getSessionAttributes = (handlerInput) => {
    return handlerInput.attributesManager.getSessionAttributes();
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getSessionAttribute = (handlerInput, attributeName) => {
    const atts = getSessionAttributes(handlerInput);
    return atts[attributeName];
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getPersistentAttributes = (handlerInput, defaultAttributes) => __awaiter(undefined, void 0, void 0, function* () {
    try {
        const data = yield handlerInput.attributesManager.getPersistentAttributes();
        if (!data)
            return defaultAttributes;
        return data;
    }
    catch (e) {
        return defaultAttributes;
    }
});

const getRequestEnvelope = (handlerInput) => {
    return handlerInput.requestEnvelope;
};
const getRequest = (handlerInput) => {
    return handlerInput.requestEnvelope.request;
};
const getRequestType = (handlerInput) => {
    return handlerInput.requestEnvelope.request.type;
};
const getSystemState = (handlerInput) => {
    return handlerInput.context.system;
};
const getContext = (handlerInput) => {
    return handlerInput.context;
};
const getRequestContext = (handlerInput) => {
    return handlerInput.requestEnvelope.context;
};
// intentRequest helpers
const isMatchedIntentName = (request, intentName) => {
    return request.intent.name === intentName;
};
const isMatchedRequestType = (handlerInput, type) => {
    return type === getRequestType(handlerInput);
};
const isIntentRequestType = (request) => {
    return request.type === 'IntentRequest';
};
// request matcher
const isIntentRequest = (handlerInput) => {
    return isMatchedRequestType(handlerInput, 'IntentRequest');
};
const isMatchedIntent = (handlerInput, intentName) => {
    const request = getRequest(handlerInput);
    if (!isIntentRequestType(request))
        return false;
    return isMatchedIntentName(request, intentName);
};
const isLaunchRequest = (handlerInput) => {
    return isMatchedRequestType(handlerInput, 'LaunchRequest');
};
const isHelpIntent = (handlerInput) => {
    return isMatchedIntent(handlerInput, 'AMAZON.HelpIntent');
};
const isYesIntent = (handlerInput) => {
    return isMatchedIntent(handlerInput, 'AMAZON.YesIntent');
};
const isNoIntent = (handlerInput) => {
    return isMatchedIntent(handlerInput, 'AMAZON.NoIntent');
};
const isStopIntent = (handlerInput) => {
    return isMatchedIntent(handlerInput, 'AMAZON.StopIntent');
};
const isCancelIntent = (handlerInput) => {
    return isMatchedIntent(handlerInput, 'AMAZON.CancelIntent');
};
// get objects
const getLocale = (handlerInput, defaultLocale = 'en-US') => {
    const request = getRequest(handlerInput);
    return request.locale || defaultLocale;
};
const getAudioPlayerState = (handlerInput) => {
    const context = getRequestContext(handlerInput);
    return context.AudioPlayer || null;
};
const getDisplayState = (handlerInput) => {
    const context = getRequestContext(handlerInput);
    return context.Display || null;
};
const getGeolocationState = (handlerInput) => {
    const context = getRequestContext(handlerInput);
    return context.Geolocation || null;
};
const getViewportState = (handlerInput) => {
    const context = getRequestContext(handlerInput);
    return context.Viewport || null;
};
const getIntent = (handlerInput) => {
    const request = getRequest(handlerInput);
    if (!isIntentRequestType(request))
        return {};
    return request.intent;
};

// fixture
const getDialogState = (request) => {
    return request.dialogState;
};
const getDialogStateFromHandler = (handlerInput) => {
    const request = getRequest(handlerInput);
    if (!isIntentRequestType(request))
        return '';
    return getDialogState(request);
};
const isMatchedDialogState = (handlerInput, state) => {
    const dialogState = getDialogStateFromHandler(handlerInput);
    if (!dialogState)
        return false;
    return dialogState === state;
};
const isDialogStarted = (handlerInput) => {
    return isMatchedDialogState(handlerInput, 'STARTED');
};
const isDialogInprogress = (handlerInput) => {
    return isMatchedDialogState(handlerInput, 'IN_PROGRESS');
};
const isDialogCompleted = (handlerInput) => {
    return isMatchedDialogState(handlerInput, 'COMPLETED');
};

const hasServiceClientFactory = (client) => {
    return client !== undefined;
};

const getRandomMessage = (messages) => {
    if (!messages || messages.length === 0)
        return '';
    const key = Math.floor(Math.random() * messages.length);
    return messages[key];
};
/**
 * Send Progressive Response
 *
 * @param handlerInput ASK-SDK handler input
 * @param speech speech text (string or SSML string)
 * @param errorHandler error handler function (optional)
 * @example
 * import { enqueueProgressiveResponse } from 'ask-utils'
 *
 * await enqueueProgressiveResponse(handlerInput, 'Now your data processing')
 */
const enqueueProgressiveResponse = (handlerInput, speech, errorHandler) => __awaiter(undefined, void 0, void 0, function* () {
    const { serviceClientFactory, requestEnvelope } = handlerInput;
    if (!hasServiceClientFactory(serviceClientFactory))
        return;
    const client = serviceClientFactory.getDirectiveServiceClient();
    const { requestId } = requestEnvelope.request;
    const payload = {
        header: {
            requestId
        },
        directive: {
            type: 'VoicePlayer.Speak',
            speech
        }
    };
    try {
        client.enqueue(payload);
    }
    catch (e) {
        if (errorHandler)
            errorHandler(e);
    }
});

const getSlot = (handlerInput, slotName) => {
    const request = getRequest(handlerInput);
    if (!isIntentRequestType(request))
        return '';
    if (request &&
        request.intent &&
        request.intent.slots &&
        request.intent.slots[slotName] &&
        request.intent.slots[slotName].value) {
        return request.intent.slots[slotName];
    }
    return '';
};
const getResolutionSlot = (slot) => {
    if (!slot)
        return '';
    const value = slot.value || '';
    if (slot.resolutions &&
        slot.resolutions.resolutionsPerAuthority &&
        slot.resolutions.resolutionsPerAuthority[0] &&
        slot.resolutions.resolutionsPerAuthority[0].status &&
        slot.resolutions.resolutionsPerAuthority[0].status.code) {
        switch (slot.resolutions.resolutionsPerAuthority[0].status.code) {
            case 'ER_SUCCESS_MATCH':
                return {
                    synonym: value,
                    resolved: slot.resolutions.resolutionsPerAuthority[0].values[0].value.name,
                    isValidated: true
                };
            case 'ER_SUCCESS_NO_MATCH':
                return {
                    synonym: value,
                    resolved: value,
                    isValidated: false
                };
            default:
                return '';
        }
    }
    else {
        return {
            synonym: value,
            resolved: value,
            isValidated: false
        };
    }
};
const getSlotValue = (handlerInput, slotName) => {
    const slot = getSlot(handlerInput, slotName);
    if (!slot)
        return '';
    const resolution = getResolutionSlot(slot);
    if (!resolution)
        return slot.value || '';
    return resolution.resolved;
};

const isConsented = (handlerInput) => {
    const { permissions } = handlerInput.requestEnvelope.context.System.user;
    if (!permissions || !permissions.consentToken)
        return false;
    return true;
};
const getUserId = (handlerInput) => {
    return handlerInput.requestEnvelope.context.System.user.userId;
};
const getSession = (handlerInput) => {
    return handlerInput.requestEnvelope.session || null;
};
const isNewSession = (handlerInput) => {
    const session = getSession(handlerInput);
    if (!session)
        return false;
    return session.new || false;
};
const getSessionId = (handlerInput) => {
    const session = getSession(handlerInput);
    if (!session)
        return '';
    return session.sessionId || '';
};
const isGrantedUserPermission = (requestEnvelope, scope) => {
    const permissions = requestEnvelope.context.System.user.permissions;
    if (!permissions)
        return false;
    if (!permissions.consentToken)
        return false;
    const { scopes } = permissions;
    if (!scopes)
        return true;
    return scopes[scope] && scopes[scope].status === 'GRANTED';
};

const getDevice = (handlerInput) => {
    return handlerInput.requestEnvelope.context.System.device;
};
const getDeviceId = (handlerInput) => {
    const device = getDevice(handlerInput);
    if (!device)
        return null;
    return device.deviceId;
};
const getSupportedInterfaces = (handlerInput) => {
    const device = getDevice(handlerInput);
    if (!device)
        return null;
    return device.supportedInterfaces;
};
const getAudioPlayerInterface = (handlerInput) => {
    const supportedInterfaces = getSupportedInterfaces(handlerInput);
    if (!supportedInterfaces)
        return {};
    return supportedInterfaces.AudioPlayer || {};
};
const getGeolocationInterface = (handlerInput) => {
    const supportedInterfaces = getSupportedInterfaces(handlerInput);
    if (!supportedInterfaces)
        return {};
    return supportedInterfaces.Geolocation || {};
};
const getAPLInterface = (handlerInput) => {
    const supportedInterfaces = getSupportedInterfaces(handlerInput);
    if (!supportedInterfaces)
        return {};
    return supportedInterfaces['Alexa.Presentation.APL'] || {};
};
const getVideoAppInterface = (handlerInput) => {
    const supportedInterfaces = getSupportedInterfaces(handlerInput);
    if (!supportedInterfaces)
        return {};
    return supportedInterfaces.VideoApp || {};
};
const getDisplayInterface = (handlerInput) => {
    const supportedInterfaces = getSupportedInterfaces(handlerInput);
    if (!supportedInterfaces)
        return {};
    return supportedInterfaces.Display || {};
};

// beta
class TranslationFactory {
    static init() {
        const translationObject = null;
        const languageStrings = {};
        return {
            addLocale(locale) {
                if (languageStrings[locale] || !translationObject)
                    return this;
                languageStrings[locale] = translationObject;
                return this;
            },
            putLocaleStrings(locale, messages) {
                if (!locale)
                    throw new Error('locale is required');
                if (!messages || Object.keys(messages).length < 1)
                    throw new Error('message object is required');
                if (typeof messages !== 'object')
                    throw new Error('message should be object');
                if (!languageStrings[locale])
                    this.addLocale(locale);
                languageStrings[locale] = {
                    translation: messages
                };
                return this;
            },
            addLocaleStrings(locale, key, message) {
                languageStrings[locale].translation[key] = message;
                return this;
            },
            getLanguageStrings() {
                return languageStrings;
            }
        };
    }
}
const TranslationGenerator = TranslationFactory.init();

var DocumentClient = awsSdk.DynamoDB.DocumentClient;
class DBClient {
    constructor(tableName, config) {
        this.client = config ? config.client || new DocumentClient() : new DocumentClient();
        this.isDebug = config ? config.isDebug || false : false;
        this.primaryKey = config ? config.primaryKey || 'id' : 'id';
        this.tableName = tableName;
    }
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                TableName: this.tableName,
                Key: {
                    [this.primaryKey]: id
                }
            };
            if (this.isDebug)
                console.log('DBClient.get: %j', param);
            const { Item } = yield this.client.get(param).promise();
            if (this.isDebug)
                console.log('DBClient.get(): %j', Item);
            if (!Item)
                return {};
            return Item;
        });
    }
    put(id, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                TableName: this.tableName,
                Item: Object.assign({ [this.primaryKey]: id }, attributes)
            };
            if (this.isDebug)
                console.log('DBClient.put: %j', param);
            const result = yield this.client.put(param).promise();
            if (this.isDebug)
                console.log('DBClient.put: %j', result);
            return result;
        });
    }
}

const RequestLogger = {
    process(handlerInput) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('[RequestLogger] RequestEnvelope: %j', handlerInput.requestEnvelope);
        });
    }
};
const ResponseLogger = {
    process(handlerInput, response) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('[ResponseLogger] RequestEnvelope: %j', handlerInput.requestEnvelope);
            console.log('[ResponseLogger] Response: %j', response);
        });
    }
};

const cloneHandler = (cloneTarget) => {
    return Object.assign({}, cloneTarget);
};
const mergeHandler = (cloneTarget, mergeObject) => {
    return Object.assign({}, cloneTarget, mergeObject);
};
const isSkillConnectionResponse = (request) => {
    return request.type === 'Connections.Response';
};
const isSkillConnectionRequest = (request) => {
    return request.type === 'Connections.Request';
};
const isSkillEvent = (requestEnvelope) => {
    return /^AlexaSkillEvent/.test(requestEnvelope.request.type);
};

class ContentBuilder {
    constructor(locale, responseBuilder) {
        this.contents = {};
        this.locale = locale;
        this.responseBuilder = responseBuilder;
    }
    isJP() {
        return /^jp/.test(this.locale);
    }
    putSpeechText(text) {
        this.contents.speechText = text;
        return this;
    }
    putRepromptText(text) {
        this.contents.repromptText = text;
        return this;
    }
    putDirectives(directives) {
        if (!this.contents.directives) {
            this.contents.directives = directives;
            return this;
        }
        this.contents.directives = this.contents.directives.concat(directives);
        return this;
    }
    putDirective(directive) {
        if (!this.contents.directives) {
            this.contents.directives = [directive];
            return this;
        }
        this.contents.directives.push(directive);
        return this;
    }
    getResponse() {
        const { speechText, repromptText, directives } = this.contents;
        if (speechText)
            this.responseBuilder.speak(speechText);
        if (repromptText)
            this.responseBuilder.reprompt(repromptText);
        if (directives)
            directives.forEach((directive) => this.responseBuilder.addDirective(directive));
        return this.responseBuilder.getResponse();
    }
}

exports.ContentBuilder = ContentBuilder;
exports.DBClient = DBClient;
exports.RequestLogger = RequestLogger;
exports.ResponseLogger = ResponseLogger;
exports.TranslationFactory = TranslationFactory;
exports.cloneHandler = cloneHandler;
exports.enqueueProgressiveResponse = enqueueProgressiveResponse;
exports.getAPLInterface = getAPLInterface;
exports.getAudioPlayerInterface = getAudioPlayerInterface;
exports.getAudioPlayerState = getAudioPlayerState;
exports.getContext = getContext;
exports.getDevice = getDevice;
exports.getDeviceId = getDeviceId;
exports.getDialogState = getDialogState;
exports.getDialogStateFromHandler = getDialogStateFromHandler;
exports.getDisplayInterface = getDisplayInterface;
exports.getDisplayState = getDisplayState;
exports.getGeolocationInterface = getGeolocationInterface;
exports.getGeolocationState = getGeolocationState;
exports.getIntent = getIntent;
exports.getLocale = getLocale;
exports.getPersistentAttributes = getPersistentAttributes;
exports.getRandomMessage = getRandomMessage;
exports.getRequest = getRequest;
exports.getRequestContext = getRequestContext;
exports.getRequestEnvelope = getRequestEnvelope;
exports.getRequestType = getRequestType;
exports.getResolutionSlot = getResolutionSlot;
exports.getSession = getSession;
exports.getSessionAttribute = getSessionAttribute;
exports.getSessionAttributes = getSessionAttributes;
exports.getSessionId = getSessionId;
exports.getSlot = getSlot;
exports.getSlotValue = getSlotValue;
exports.getSupportedInterfaces = getSupportedInterfaces;
exports.getSystemState = getSystemState;
exports.getUserId = getUserId;
exports.getVideoAppInterface = getVideoAppInterface;
exports.getViewportState = getViewportState;
exports.hasServiceClientFactory = hasServiceClientFactory;
exports.isCancelIntent = isCancelIntent;
exports.isConsented = isConsented;
exports.isDialogCompleted = isDialogCompleted;
exports.isDialogInprogress = isDialogInprogress;
exports.isDialogStarted = isDialogStarted;
exports.isGrantedUserPermission = isGrantedUserPermission;
exports.isHelpIntent = isHelpIntent;
exports.isIntentRequest = isIntentRequest;
exports.isIntentRequestType = isIntentRequestType;
exports.isLaunchRequest = isLaunchRequest;
exports.isMatchedDialogState = isMatchedDialogState;
exports.isMatchedIntent = isMatchedIntent;
exports.isMatchedIntentName = isMatchedIntentName;
exports.isMatchedRequestType = isMatchedRequestType;
exports.isNewSession = isNewSession;
exports.isNoIntent = isNoIntent;
exports.isSkillConnectionRequest = isSkillConnectionRequest;
exports.isSkillConnectionResponse = isSkillConnectionResponse;
exports.isSkillEvent = isSkillEvent;
exports.isStopIntent = isStopIntent;
exports.isYesIntent = isYesIntent;
exports.mergeHandler = mergeHandler;
exports.updateSessionAttributes = updateSessionAttributes;
